{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SkidKit documentation This is the home for all documentation pertaining to SkidKit related projects Main site (NOTE: Doesn't support mobile yet ): /basil.is-a.dev/ Project list: Interface Component","title":"Home"},{"location":"#skidkit-documentation","text":"","title":"SkidKit documentation"},{"location":"#this-is-the-home-for-all-documentation-pertaining-to-skidkit-related-projects","text":"","title":"This is the home for all documentation pertaining to SkidKit related projects"},{"location":"#main-site-note-doesnt-support-mobile-yet","text":"/basil.is-a.dev/","title":"Main site (NOTE: Doesn't support mobile yet):"},{"location":"#project-list","text":"Interface Component","title":"Project list:"},{"location":"InterfaceComponent/box_model/","text":"Box model About Note My box model implementation is loosely based on this . The box model has: Margin Border Padding The box model is used for sizing and positioning elements Image credit: W3Schools Creating a box Note PADDING should be substituted with an Integer value for padding LINETYPE should be substituted with a member of the LineType enum BORDER_WIDTH should be substituted with an Integer value for the border's width R, G, B should be substituted with Integer values for red , green and blue MARGIN should be substituted with an Integer value for margin 1 2 3 4 new Box ( PADDING , new Border ( BORDER_WIDTH , LINETYPE , new Colour ( R , G , B )), MARGIN ) Polling size from box Note Size is calculated like so: \\(padding + borderwidth + margin\\) Example 1 2 3 4 5 6 7 8 Box box = new Box ( 20 , new Border ( 30 , LINETYPE , new Colour ( 255 , 255 , 255 )), 50 ); System . out . println ( box . getFull ()) // Outputs 20 + 30 + 50 = 100 1 box . getFull () Getters and setters GetBorder Return value: Box object 1 public Border getBorder (); GetMargin Return value: Integer margin value of the Box object 1 public int getMargin (); GetPadding Return value: Integer padding value of the Box object 1 public int getPadding (); GetFull Return value: Integer full size value of the Box object 1 public int getFull (); SetBorder Return value: void Params: Border border value to set the Box object's border to 1 public void setBorder ( Border border ); SetBorderType Return value: void Params: LineType border line type value to set the Box object's border's line type to 1 public void setBorderType ( LineType lineType ); SetBorderColour Return value: void Params: Colour border colour value to set the Box object's border's colour to 1 public void setBorderColour ( Colour colour ); SetBorderSize Return value: void Params: Integer border size value to set the Box object's border's size to 1 public void setBorderSize ( int size ); SetMargin Return value: void Params: Integer margin size value to set the Box object's margin size to 1 public void setMargin ( int margin ); SetPadding Return value: void Params: Integer padding size value to set the Box object's padding size to 1 public void setPadding ( int padding );","title":"Box Model"},{"location":"InterfaceComponent/box_model/#box-model","text":"","title":"Box model"},{"location":"InterfaceComponent/box_model/#about","text":"Note My box model implementation is loosely based on this . The box model has: Margin Border Padding The box model is used for sizing and positioning elements Image credit: W3Schools","title":"About"},{"location":"InterfaceComponent/box_model/#creating-a-box","text":"Note PADDING should be substituted with an Integer value for padding LINETYPE should be substituted with a member of the LineType enum BORDER_WIDTH should be substituted with an Integer value for the border's width R, G, B should be substituted with Integer values for red , green and blue MARGIN should be substituted with an Integer value for margin 1 2 3 4 new Box ( PADDING , new Border ( BORDER_WIDTH , LINETYPE , new Colour ( R , G , B )), MARGIN )","title":"Creating a box"},{"location":"InterfaceComponent/box_model/#polling-size-from-box","text":"Note Size is calculated like so: \\(padding + borderwidth + margin\\) Example 1 2 3 4 5 6 7 8 Box box = new Box ( 20 , new Border ( 30 , LINETYPE , new Colour ( 255 , 255 , 255 )), 50 ); System . out . println ( box . getFull ()) // Outputs 20 + 30 + 50 = 100 1 box . getFull ()","title":"Polling size from box"},{"location":"InterfaceComponent/box_model/#getters-and-setters","text":"","title":"Getters and setters"},{"location":"InterfaceComponent/box_model/#getborder","text":"","title":"GetBorder"},{"location":"InterfaceComponent/box_model/#return-value-box-object","text":"1 public Border getBorder ();","title":"Return value: Box object"},{"location":"InterfaceComponent/box_model/#getmargin","text":"","title":"GetMargin"},{"location":"InterfaceComponent/box_model/#return-value-integer-margin-value-of-the-box-object","text":"1 public int getMargin ();","title":"Return value: Integer margin value of the Box object"},{"location":"InterfaceComponent/box_model/#getpadding","text":"","title":"GetPadding"},{"location":"InterfaceComponent/box_model/#return-value-integer-padding-value-of-the-box-object","text":"1 public int getPadding ();","title":"Return value: Integer padding value of the Box object"},{"location":"InterfaceComponent/box_model/#getfull","text":"","title":"GetFull"},{"location":"InterfaceComponent/box_model/#return-value-integer-full-size-value-of-the-box-object","text":"1 public int getFull ();","title":"Return value: Integer full size value of the Box object"},{"location":"InterfaceComponent/box_model/#setborder","text":"","title":"SetBorder"},{"location":"InterfaceComponent/box_model/#return-value-void","text":"","title":"Return value: void"},{"location":"InterfaceComponent/box_model/#params-border-border-value-to-set-the-box-objects-border-to","text":"1 public void setBorder ( Border border );","title":"Params: Border border value to set the Box object's border to"},{"location":"InterfaceComponent/box_model/#setbordertype","text":"","title":"SetBorderType"},{"location":"InterfaceComponent/box_model/#return-value-void_1","text":"","title":"Return value: void"},{"location":"InterfaceComponent/box_model/#params-linetype-border-line-type-value-to-set-the-box-objects-borders-line-type-to","text":"1 public void setBorderType ( LineType lineType );","title":"Params: LineType border line type value to set the Box object's border's line type to"},{"location":"InterfaceComponent/box_model/#setbordercolour","text":"","title":"SetBorderColour"},{"location":"InterfaceComponent/box_model/#return-value-void_2","text":"","title":"Return value: void"},{"location":"InterfaceComponent/box_model/#params-colour-border-colour-value-to-set-the-box-objects-borders-colour-to","text":"1 public void setBorderColour ( Colour colour );","title":"Params: Colour border colour value to set the Box object's border's colour to"},{"location":"InterfaceComponent/box_model/#setbordersize","text":"","title":"SetBorderSize"},{"location":"InterfaceComponent/box_model/#return-value-void_3","text":"","title":"Return value: void"},{"location":"InterfaceComponent/box_model/#params-integer-border-size-value-to-set-the-box-objects-borders-size-to","text":"1 public void setBorderSize ( int size );","title":"Params: Integer border size value to set the Box object's border's size to"},{"location":"InterfaceComponent/box_model/#setmargin","text":"","title":"SetMargin"},{"location":"InterfaceComponent/box_model/#return-value-void_4","text":"","title":"Return value: void"},{"location":"InterfaceComponent/box_model/#params-integer-margin-size-value-to-set-the-box-objects-margin-size-to","text":"1 public void setMargin ( int margin );","title":"Params: Integer margin size value to set the Box object's margin size to"},{"location":"InterfaceComponent/box_model/#setpadding","text":"","title":"SetPadding"},{"location":"InterfaceComponent/box_model/#return-value-void_5","text":"","title":"Return value: void"},{"location":"InterfaceComponent/box_model/#params-integer-padding-size-value-to-set-the-box-objects-padding-size-to","text":"1 public void setPadding ( int padding );","title":"Params: Integer padding size value to set the Box object's padding size to"},{"location":"InterfaceComponent/interface_component/","text":"Interface component Warning This library is largely untested and incomplete, please heed warning before using it. Where can I get it? Right here (github link) What? A bare-bones set of tools to make your own GUI framework, completely generic, and Java 8 compliant. Why? I noticed a severe lack of GUI frameworks with the ability to be able to be used anywhere, so I created this to expand options Design goals An extensible DOM based UI framework Some sort of stylesheet system Options: Code based (due to requirement of ease of use and the fastest option) Box model Extensibility via multiple backend support, that can easily be implemented by user No dependencies, this is non negotiable Usage example Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 public class TestInterfaceComponent { public static Stylesheet stylesheet = new Stylesheet () . addRule ( new Rule ( \"test-1\" ) . addOptionInt ( \"width\" , 200 ) . addOptionString ( \"type\" , \"relative\" ) . addOptionBox ( \"box\" , new Box ( 20 , new Border ( 20 , LineType . SOLID , new Colour ( 255 , 255 , 255 )), 50 )) ) . addRule ( new Rule ( \"test-2\" ) . addOptionLayout ( \"top\" , new Layout ( 2 , LayoutTypes . RELATIVE )) . addOptionLayout ( \"left\" , new Layout ( 2 , LayoutTypes . RELATIVE )) ); public static void main ( String [] args ) { System . out . println ( \"------------------------------\\n\\nRUNNING TESTS:\\n\\n------------------------------\\n\" ); testStylesheet (); testElement (); System . out . println ( \"\\n------------------------------\\n\\nEND TESTS\\n\\n------------------------------\" ); } public static void testStylesheet () { System . out . println ( \"Stylesheet test: \" + stylesheet . getRules () . get ( 0 ) . getOptions () . get ( 1 ) . getOption () . getRight ()); } public static void testElement () { Surface surface = new Surface ( new Primitives () { @Override public void draw ( Element element ) { System . out . println ( \"Drew a thing.\" ); } }). addElement ( new Element ( stylesheet , \"sl1-element\" , \"test-1\" , \"test-2\" ) ). addElement ( new Element ( stylesheet , \"sl2-element\" , \"test-1\" , \"test-2\" ) ); System . out . println ( \"Element test 1 (1): \" + surface . getScreen (). getChildren (). get ( 0 ). getCalculatedPositionX () ); System . out . println ( \"Element test 1 (2): \" + surface . getScreen (). getChildren (). get ( 0 ). getCalculatedPositionY () ); System . out . println ( \"\\nElement test 2: \" + surface . getScreen (). getChildren (). get ( 0 ). getSize (). getBorder (). getWidth () ); System . out . println ( \"\\nElement test 3: \" ); surface . render (); System . out . println ( \"\\nElement test 4: \" ); System . out . println ( surface . getScreen (). getChildren (). get ( 0 ). getRoot (). getIds () [ 0 ] ); } }","title":"About"},{"location":"InterfaceComponent/interface_component/#interface-component","text":"Warning This library is largely untested and incomplete, please heed warning before using it.","title":"Interface component"},{"location":"InterfaceComponent/interface_component/#where-can-i-get-it","text":"Right here (github link)","title":"Where can I get it?"},{"location":"InterfaceComponent/interface_component/#what","text":"A bare-bones set of tools to make your own GUI framework, completely generic, and Java 8 compliant.","title":"What?"},{"location":"InterfaceComponent/interface_component/#why","text":"I noticed a severe lack of GUI frameworks with the ability to be able to be used anywhere, so I created this to expand options","title":"Why?"},{"location":"InterfaceComponent/interface_component/#design-goals","text":"An extensible DOM based UI framework Some sort of stylesheet system Options: Code based (due to requirement of ease of use and the fastest option) Box model Extensibility via multiple backend support, that can easily be implemented by user No dependencies, this is non negotiable","title":"Design goals"},{"location":"InterfaceComponent/interface_component/#usage-example","text":"Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 public class TestInterfaceComponent { public static Stylesheet stylesheet = new Stylesheet () . addRule ( new Rule ( \"test-1\" ) . addOptionInt ( \"width\" , 200 ) . addOptionString ( \"type\" , \"relative\" ) . addOptionBox ( \"box\" , new Box ( 20 , new Border ( 20 , LineType . SOLID , new Colour ( 255 , 255 , 255 )), 50 )) ) . addRule ( new Rule ( \"test-2\" ) . addOptionLayout ( \"top\" , new Layout ( 2 , LayoutTypes . RELATIVE )) . addOptionLayout ( \"left\" , new Layout ( 2 , LayoutTypes . RELATIVE )) ); public static void main ( String [] args ) { System . out . println ( \"------------------------------\\n\\nRUNNING TESTS:\\n\\n------------------------------\\n\" ); testStylesheet (); testElement (); System . out . println ( \"\\n------------------------------\\n\\nEND TESTS\\n\\n------------------------------\" ); } public static void testStylesheet () { System . out . println ( \"Stylesheet test: \" + stylesheet . getRules () . get ( 0 ) . getOptions () . get ( 1 ) . getOption () . getRight ()); } public static void testElement () { Surface surface = new Surface ( new Primitives () { @Override public void draw ( Element element ) { System . out . println ( \"Drew a thing.\" ); } }). addElement ( new Element ( stylesheet , \"sl1-element\" , \"test-1\" , \"test-2\" ) ). addElement ( new Element ( stylesheet , \"sl2-element\" , \"test-1\" , \"test-2\" ) ); System . out . println ( \"Element test 1 (1): \" + surface . getScreen (). getChildren (). get ( 0 ). getCalculatedPositionX () ); System . out . println ( \"Element test 1 (2): \" + surface . getScreen (). getChildren (). get ( 0 ). getCalculatedPositionY () ); System . out . println ( \"\\nElement test 2: \" + surface . getScreen (). getChildren (). get ( 0 ). getSize (). getBorder (). getWidth () ); System . out . println ( \"\\nElement test 3: \" ); surface . render (); System . out . println ( \"\\nElement test 4: \" ); System . out . println ( surface . getScreen (). getChildren (). get ( 0 ). getRoot (). getIds () [ 0 ] ); } }","title":"Usage example"},{"location":"InterfaceComponent/layouts/","text":"Layouts About Note Layouts are loosely based on this . Currently there are 2 types of layouts: ABSOLUTE RELATIVE Which are stored in the enum LayoutTypes . Creating a layout Note POSITION should be subsituted with an Integer value LAYOUT_TYPE should be substituted with a member of the LayoutTypes enum 1 new Layout ( POSITION , LayoutTypes . LAYOUT_TYPE ) Polling position from layout Note CONSTRAINT_X should be subsituted with an Integer value What each layout type will return: ABSOLUTE = \\(position\\) RELATIVE = \\(constraint / position\\) Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* * LayoutType.RELATIVE example * 5 = position (Integer) */ Layout layout = new Layout ( 5 , LayoutType . RELATIVE ); System . out . println ( layout . calculate position ( 2 )); // Outputs 5 / 2 = 2.5 ... /* * LayoutType.ABSOLUTE example * 10 = position (Integer) */ Layout layout = new Layout ( 5 , LayoutType . ABSOLUTE ); System . out . println ( layout . calculate position ( 2 )); // Outputs 10 1 layout . calculatePosition ( CONSTRAINT_X ) Setters and getters GetType Return value: LayoutTypes type value of the Layout object 1 public LayoutTypes getType (); GetPosition Return value: Integer position value of the Layout object 1 public int getPosition (); SetPosition Return value: void Params: int position value to set the Layout object's position to 1 public void setPosition ( int position ) SetType Return value: void Params: LayoutTypes type value to set the Layout object's layout type to 1 public void setType ( LayoutTypes type )","title":"Layouts"},{"location":"InterfaceComponent/layouts/#layouts","text":"","title":"Layouts"},{"location":"InterfaceComponent/layouts/#about","text":"Note Layouts are loosely based on this . Currently there are 2 types of layouts: ABSOLUTE RELATIVE Which are stored in the enum LayoutTypes .","title":"About"},{"location":"InterfaceComponent/layouts/#creating-a-layout","text":"Note POSITION should be subsituted with an Integer value LAYOUT_TYPE should be substituted with a member of the LayoutTypes enum 1 new Layout ( POSITION , LayoutTypes . LAYOUT_TYPE )","title":"Creating a layout"},{"location":"InterfaceComponent/layouts/#polling-position-from-layout","text":"Note CONSTRAINT_X should be subsituted with an Integer value What each layout type will return: ABSOLUTE = \\(position\\) RELATIVE = \\(constraint / position\\) Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* * LayoutType.RELATIVE example * 5 = position (Integer) */ Layout layout = new Layout ( 5 , LayoutType . RELATIVE ); System . out . println ( layout . calculate position ( 2 )); // Outputs 5 / 2 = 2.5 ... /* * LayoutType.ABSOLUTE example * 10 = position (Integer) */ Layout layout = new Layout ( 5 , LayoutType . ABSOLUTE ); System . out . println ( layout . calculate position ( 2 )); // Outputs 10 1 layout . calculatePosition ( CONSTRAINT_X )","title":"Polling position from layout"},{"location":"InterfaceComponent/layouts/#setters-and-getters","text":"","title":"Setters and getters"},{"location":"InterfaceComponent/layouts/#gettype","text":"","title":"GetType"},{"location":"InterfaceComponent/layouts/#return-value-layouttypes-type-value-of-the-layout-object","text":"1 public LayoutTypes getType ();","title":"Return value: LayoutTypes type value of the Layout object"},{"location":"InterfaceComponent/layouts/#getposition","text":"","title":"GetPosition"},{"location":"InterfaceComponent/layouts/#return-value-integer-position-value-of-the-layout-object","text":"1 public int getPosition ();","title":"Return value: Integer position value of the Layout object"},{"location":"InterfaceComponent/layouts/#setposition","text":"","title":"SetPosition"},{"location":"InterfaceComponent/layouts/#return-value-void","text":"","title":"Return value: void"},{"location":"InterfaceComponent/layouts/#params-int-position-value-to-set-the-layout-objects-position-to","text":"1 public void setPosition ( int position )","title":"Params: int position value to set the Layout object's position to"},{"location":"InterfaceComponent/layouts/#settype","text":"","title":"SetType"},{"location":"InterfaceComponent/layouts/#return-value-void_1","text":"","title":"Return value: void"},{"location":"InterfaceComponent/layouts/#params-layouttypes-type-value-to-set-the-layout-objects-layout-type-to","text":"1 public void setType ( LayoutTypes type )","title":"Params: LayoutTypes type value to set the Layout object's layout type to"},{"location":"InterfaceComponent/stylesheets/","text":"Stylesheets About Note Stylesheets are very loosely based on this . Stylesheets have a rule based structure, like so: Note Stylesheets have a rule based system, so you add a rule with a ID to specify which Element s you want to modify, then you can add Option s of different types 1 2 3 4 5 \"ID\" { \"Position\" : 20 ... } Making style sheets My code based implementation of stylesheets uses method chaining to build a stylesheet. Warning This example showcases specific options with specific parameters. However, you may add as many, or as little options as you want, and change the parameters to the options how you want. All options are optional. 1 2 3 4 5 6 7 8 9 10 11 12 new Stylesheet () . addRule ( new Rule ( \"test-1\" ) . addOptionInt ( \"width\" , 200 ) . addOptionString ( \"type\" , \"relative\" ) . addOptionBox ( \"box\" , new Box ( 20 , new Border ( 20 , LineType . SOLID , new Colour ( 255 , 255 , 255 )), 50 )) ) . addRule ( new Rule ( \"test-2\" ) . addOptionLayout ( \"top\" , new Layout ( 2 , LayoutTypes . RELATIVE )) . addOptionLayout ( \"left\" , new Layout ( 2 , LayoutTypes . RELATIVE )) ); Rules A rule takes one parameter id , this specifies the scope that this rule can modify. Note ID should be subsituted with a String value 1 new Rule ( ID ) You may then chain on Option s to the Rule object Note ID should be subsituted with a String value TYPE should be subsituted with the end to a method prefixed with addOption in the Rule class NAME should be subsituted with a String value VALUE should be substituted with the value addOptionTYPE accepts 1 2 new Rule ( ID ) . addOptionTYPE ( NAME , VALUE ); Polling a stylesheet box You can get a box from the stylesheet with the method parseIntoBox Example 1 2 3 4 5 6 7 8 9 new Stylesheet () new Rule ( \"test-1\" ) . addOptionBox ( \"box\" , new Box ( 20 , new Border ( 20 , LineType . SOLID , new Colour ( 255 , 255 , 255 )), 50 )); System . out . println ( stylesheet . parseIntoBox (). getMargin ()); // Outputs the margin of the box (50) 1 stylesheet . parseIntoBox () Polling a stylesheet layout You can get a box from the stylesheet with the ugly hunk of a method called parseIntoLayout Example 1 2 3 4 5 6 7 8 new Stylesheet () new Rule ( \"test-1\" ) . addOptionLayout ( \"top\" , new Layout ( 2 , LayoutTypes . RELATIVE )) . addOptionLayout ( \"left\" , new Layout ( 2 , LayoutTypes . RELATIVE )) System . out . println ( stylesheet . parseIntoLayout (). getPosition ()); // Outputs the position of the layout (N/A) 1 stylesheet . parseIntoLayout () Getters and setters GetRules Return value: java.util.ArrayList<Rule> rules that the stylesheet contains 1 public ArrayList < Rule > getRules ();","title":"Stylesheets"},{"location":"InterfaceComponent/stylesheets/#stylesheets","text":"","title":"Stylesheets"},{"location":"InterfaceComponent/stylesheets/#about","text":"Note Stylesheets are very loosely based on this . Stylesheets have a rule based structure, like so: Note Stylesheets have a rule based system, so you add a rule with a ID to specify which Element s you want to modify, then you can add Option s of different types 1 2 3 4 5 \"ID\" { \"Position\" : 20 ... }","title":"About"},{"location":"InterfaceComponent/stylesheets/#making-style-sheets","text":"My code based implementation of stylesheets uses method chaining to build a stylesheet. Warning This example showcases specific options with specific parameters. However, you may add as many, or as little options as you want, and change the parameters to the options how you want. All options are optional. 1 2 3 4 5 6 7 8 9 10 11 12 new Stylesheet () . addRule ( new Rule ( \"test-1\" ) . addOptionInt ( \"width\" , 200 ) . addOptionString ( \"type\" , \"relative\" ) . addOptionBox ( \"box\" , new Box ( 20 , new Border ( 20 , LineType . SOLID , new Colour ( 255 , 255 , 255 )), 50 )) ) . addRule ( new Rule ( \"test-2\" ) . addOptionLayout ( \"top\" , new Layout ( 2 , LayoutTypes . RELATIVE )) . addOptionLayout ( \"left\" , new Layout ( 2 , LayoutTypes . RELATIVE )) );","title":"Making style sheets"},{"location":"InterfaceComponent/stylesheets/#rules","text":"A rule takes one parameter id , this specifies the scope that this rule can modify. Note ID should be subsituted with a String value 1 new Rule ( ID ) You may then chain on Option s to the Rule object Note ID should be subsituted with a String value TYPE should be subsituted with the end to a method prefixed with addOption in the Rule class NAME should be subsituted with a String value VALUE should be substituted with the value addOptionTYPE accepts 1 2 new Rule ( ID ) . addOptionTYPE ( NAME , VALUE );","title":"Rules"},{"location":"InterfaceComponent/stylesheets/#polling-a-stylesheet-box","text":"You can get a box from the stylesheet with the method parseIntoBox Example 1 2 3 4 5 6 7 8 9 new Stylesheet () new Rule ( \"test-1\" ) . addOptionBox ( \"box\" , new Box ( 20 , new Border ( 20 , LineType . SOLID , new Colour ( 255 , 255 , 255 )), 50 )); System . out . println ( stylesheet . parseIntoBox (). getMargin ()); // Outputs the margin of the box (50) 1 stylesheet . parseIntoBox ()","title":"Polling a stylesheet box"},{"location":"InterfaceComponent/stylesheets/#polling-a-stylesheet-layout","text":"You can get a box from the stylesheet with the ugly hunk of a method called parseIntoLayout Example 1 2 3 4 5 6 7 8 new Stylesheet () new Rule ( \"test-1\" ) . addOptionLayout ( \"top\" , new Layout ( 2 , LayoutTypes . RELATIVE )) . addOptionLayout ( \"left\" , new Layout ( 2 , LayoutTypes . RELATIVE )) System . out . println ( stylesheet . parseIntoLayout (). getPosition ()); // Outputs the position of the layout (N/A) 1 stylesheet . parseIntoLayout ()","title":"Polling a stylesheet layout"},{"location":"InterfaceComponent/stylesheets/#getters-and-setters","text":"","title":"Getters and setters"},{"location":"InterfaceComponent/stylesheets/#getrules","text":"","title":"GetRules"},{"location":"InterfaceComponent/stylesheets/#return-value-javautilarraylistrule-rules-that-the-stylesheet-contains","text":"1 public ArrayList < Rule > getRules ();","title":"Return value: java.util.ArrayList&lt;Rule&gt; rules that the stylesheet contains"},{"location":"InterfaceComponent/surfaces_and_elements/","text":"Surfaces & Elements Surface Surface A class that loops through and renders Element objects, it also defines a top level Element that you can add to Warning Primitives is largely incomplete A surface contains a Primitives interface, which defines methods for drawing, and can be overriden 1 2 3 4 5 6 7 8 9 10 11 // prim.java class prim implements Primitives { @Override public void draw ( Element element ) { System . out . println ( \"Drew a thing.\" ); } } // main.java Surface surface = new Surface ( new prim ()); Adding elements Element addition is done using method chaining, much like with Stylesheets Note ELEMENT should be substituted with the Element object that you would like to add 1 2 Surface surface = new Surface ( new prim ()) . addElement ( ELEMENT ); Rendering This can be simply done with the method render() 1 surface . render () Getters and setters GetScreen Return value: Element screen value, returns the top level element 1 public Element getScreen () Element Element An individual element of the UI, it is constructed with a Stylesheet and a set of ids Elements are arranged in a tree like structure Note STYLESHEET should be substituted with a Stylesheet object ID1, ID2, ... should be substituted with the String ids you want the object to have 1 new Element ( STYLESHEET , ID1 , ID2 , ...) Adding elements Element addition is done using method chaining, much like with Stylesheets Note ELEMENT should be substituted with the Element object that you would like to add 1 2 3 element . add ( ELEMENT ) . add (...); Iterating through an Element This can simply be done with a loop Note ROOT_ELEMENT should be substituted with the Element object that you would like to loop from 1 2 3 4 for ( Element e : ROOT_ELEMENT ) { // ... } Getters and setters GetChildren Return value: ArrayList<Element> the children of the Element 1 public ArrayList < Element > getChildren () GetParent Return value: Element the Element 's parent 1 public Element getParent () IsRoot Return value: boolean whether this is the top level Element in the tree 1 public boolean isRoot () GetRoot Return value: Element the heirachial root of the Element tree 1 public Element getRoot () GetSize Return value: Box the size of the Element 1 public Box getSize () GetPosition Return value: Pair<Layout, Layout> the position of the Element 1 public Pair < Layout , Layout > getPosition () GetCalculatedPositionX Return value: int a calculated x position based on the size of the parent Element 1 public int getCalculatedPositionX () GetCalculatedPositionY Return value: int a calculated y position based on the size of the parent Element 1 public int getCalculatedPositionY () GetStylesheet Return value: Stylesheet the Element 's stylesheet 1 public Stylesheet getStylesheet () GetIds Return value: String[] the ids the Element has 1 public String [] getIds () SetSize Return value: void Params: Box size to set the Element 's size to 1 public void setSize ( Box size ) SetPosition Return value: void Params: Pair<Layout, Layout> position value to set the Element object's position to 1 public void setPosition ( Pair < Layout , Layout > position )","title":"Surfaces & Elements"},{"location":"InterfaceComponent/surfaces_and_elements/#surfaces-elements","text":"Surface","title":"Surfaces &amp; Elements"},{"location":"InterfaceComponent/surfaces_and_elements/#surface","text":"A class that loops through and renders Element objects, it also defines a top level Element that you can add to Warning Primitives is largely incomplete A surface contains a Primitives interface, which defines methods for drawing, and can be overriden 1 2 3 4 5 6 7 8 9 10 11 // prim.java class prim implements Primitives { @Override public void draw ( Element element ) { System . out . println ( \"Drew a thing.\" ); } } // main.java Surface surface = new Surface ( new prim ());","title":"Surface"},{"location":"InterfaceComponent/surfaces_and_elements/#adding-elements","text":"Element addition is done using method chaining, much like with Stylesheets Note ELEMENT should be substituted with the Element object that you would like to add 1 2 Surface surface = new Surface ( new prim ()) . addElement ( ELEMENT );","title":"Adding elements"},{"location":"InterfaceComponent/surfaces_and_elements/#rendering","text":"This can be simply done with the method render() 1 surface . render ()","title":"Rendering"},{"location":"InterfaceComponent/surfaces_and_elements/#getters-and-setters","text":"","title":"Getters and setters"},{"location":"InterfaceComponent/surfaces_and_elements/#getscreen","text":"","title":"GetScreen"},{"location":"InterfaceComponent/surfaces_and_elements/#return-value-element-screen-value-returns-the-top-level-element","text":"1 public Element getScreen () Element","title":"Return value: Element screen value, returns the top level element"},{"location":"InterfaceComponent/surfaces_and_elements/#element","text":"An individual element of the UI, it is constructed with a Stylesheet and a set of ids Elements are arranged in a tree like structure Note STYLESHEET should be substituted with a Stylesheet object ID1, ID2, ... should be substituted with the String ids you want the object to have 1 new Element ( STYLESHEET , ID1 , ID2 , ...)","title":"Element"},{"location":"InterfaceComponent/surfaces_and_elements/#adding-elements_1","text":"Element addition is done using method chaining, much like with Stylesheets Note ELEMENT should be substituted with the Element object that you would like to add 1 2 3 element . add ( ELEMENT ) . add (...);","title":"Adding elements"},{"location":"InterfaceComponent/surfaces_and_elements/#iterating-through-an-element","text":"This can simply be done with a loop Note ROOT_ELEMENT should be substituted with the Element object that you would like to loop from 1 2 3 4 for ( Element e : ROOT_ELEMENT ) { // ... }","title":"Iterating through an Element"},{"location":"InterfaceComponent/surfaces_and_elements/#getters-and-setters_1","text":"","title":"Getters and setters"},{"location":"InterfaceComponent/surfaces_and_elements/#getchildren","text":"","title":"GetChildren"},{"location":"InterfaceComponent/surfaces_and_elements/#return-value-arraylistelement-the-children-of-the-element","text":"1 public ArrayList < Element > getChildren ()","title":"Return value: ArrayList&lt;Element&gt; the children of the Element"},{"location":"InterfaceComponent/surfaces_and_elements/#getparent","text":"","title":"GetParent"},{"location":"InterfaceComponent/surfaces_and_elements/#return-value-element-the-elements-parent","text":"1 public Element getParent ()","title":"Return value: Element the Element's parent"},{"location":"InterfaceComponent/surfaces_and_elements/#isroot","text":"","title":"IsRoot"},{"location":"InterfaceComponent/surfaces_and_elements/#return-value-boolean-whether-this-is-the-top-level-element-in-the-tree","text":"1 public boolean isRoot ()","title":"Return value: boolean whether this is the top level Element in the tree"},{"location":"InterfaceComponent/surfaces_and_elements/#getroot","text":"","title":"GetRoot"},{"location":"InterfaceComponent/surfaces_and_elements/#return-value-element-the-heirachial-root-of-the-element-tree","text":"1 public Element getRoot ()","title":"Return value: Element the heirachial root of the Element tree"},{"location":"InterfaceComponent/surfaces_and_elements/#getsize","text":"","title":"GetSize"},{"location":"InterfaceComponent/surfaces_and_elements/#return-value-box-the-size-of-the-element","text":"1 public Box getSize ()","title":"Return value: Box the size of the Element"},{"location":"InterfaceComponent/surfaces_and_elements/#getposition","text":"","title":"GetPosition"},{"location":"InterfaceComponent/surfaces_and_elements/#return-value-pairlayout-layout-the-position-of-the-element","text":"1 public Pair < Layout , Layout > getPosition ()","title":"Return value: Pair&lt;Layout, Layout&gt; the position of the Element"},{"location":"InterfaceComponent/surfaces_and_elements/#getcalculatedpositionx","text":"","title":"GetCalculatedPositionX"},{"location":"InterfaceComponent/surfaces_and_elements/#return-value-int-a-calculated-x-position-based-on-the-size-of-the-parent-element","text":"1 public int getCalculatedPositionX ()","title":"Return value: int a calculated x position based on the size of the parent Element"},{"location":"InterfaceComponent/surfaces_and_elements/#getcalculatedpositiony","text":"","title":"GetCalculatedPositionY"},{"location":"InterfaceComponent/surfaces_and_elements/#return-value-int-a-calculated-y-position-based-on-the-size-of-the-parent-element","text":"1 public int getCalculatedPositionY ()","title":"Return value: int a calculated y position based on the size of the parent Element"},{"location":"InterfaceComponent/surfaces_and_elements/#getstylesheet","text":"","title":"GetStylesheet"},{"location":"InterfaceComponent/surfaces_and_elements/#return-value-stylesheet-the-elements-stylesheet","text":"1 public Stylesheet getStylesheet ()","title":"Return value: Stylesheet the Element's stylesheet"},{"location":"InterfaceComponent/surfaces_and_elements/#getids","text":"","title":"GetIds"},{"location":"InterfaceComponent/surfaces_and_elements/#return-value-string-the-ids-the-element-has","text":"1 public String [] getIds ()","title":"Return value: String[] the ids the Element has"},{"location":"InterfaceComponent/surfaces_and_elements/#setsize","text":"","title":"SetSize"},{"location":"InterfaceComponent/surfaces_and_elements/#return-value-void","text":"","title":"Return value: void"},{"location":"InterfaceComponent/surfaces_and_elements/#params-box-size-to-set-the-elements-size-to","text":"1 public void setSize ( Box size )","title":"Params: Box size to set the Element's size to"},{"location":"InterfaceComponent/surfaces_and_elements/#setposition","text":"","title":"SetPosition"},{"location":"InterfaceComponent/surfaces_and_elements/#return-value-void_1","text":"","title":"Return value: void"},{"location":"InterfaceComponent/surfaces_and_elements/#params-pairlayout-layout-position-value-to-set-the-element-objects-position-to","text":"1 public void setPosition ( Pair < Layout , Layout > position )","title":"Params: Pair&lt;Layout, Layout&gt; position value to set the Element object's position to"},{"location":"articles/minecraft_and_cpp/","text":"Minecraft and C++ Foreword Interfacing with Minecraft in C++ is a relatively unexplored topic, only really explored by the likes of cheat clients, so I spent a small bit of time implementing a (small) program to interface with Minecraft, the results can be seen here I also built a small program to allow people to 'skid' from and make their own implementations pertaining to Minecraft and C++ Attack vector So, first I had to choose the way I want to interface with Minecraft, I'm sure there are many other methods, but I decided to settle with DLL injection DLL injection would allow me to read and write to the memory of the process (Minecraft) Making fire with my bare hands So I had to make the program actually compile to a DLL, this is simply done with the singular cmake line: 1 add_library ( ${ PROJECT_NAME } SHARED ${ SRC } ) Then I had to create the entry point for the program, which also can simply be done with the special entry point DllMain Note This checks if the reason for usage is to attach an executable, and if so, starts a new thread with the purpose of setting everything up and ectera 1 2 3 4 5 6 7 8 9 BOOL APIENTRY DllMain ( HINSTANCE hinstDLL , DWORD fdwReason , LPVOID lpvReserved ) { if ( fdwReason == DLL_PROCESS_ATTACH ) { CreateThread ( nullptr , 0 , ( LPTHREAD_START_ROUTINE ) injectDLL , nullptr , 0 , nullptr ); } return TRUE ; } Injecting the poison in the coffee I needed a tool with the purpose of injecting DLL's into programs. So, I had a look through the internet, and found Process Hacker , this is a pretty nifty program, that allows you to view many different things like what programs are eating away at a file you want to delete, and, as a nice bonus, it also sets of the least Windows Defender flags Interfacing with coffee To actually interface with Java, I had to use a library by the name of JNI So, now with JNI in my toolkit, I need to do the following steps to mess around with Minecraft: Get the created Java virtual machines, and feed the first result into a jvm variable Get the runtime environment, this would allow me to mess with Minecraft by calling functions and such Lastly, attach the current thread to the java virtual machine That was straight forward enough to be sprawled out on a grand total of 17 lines! You may see how I did it in more depth here Coffee does not bond well with incremented letters So, it's pretty obvious that Java isn't C++, in the slightest, which means, the pain of mapping Java to a slightly less high level language will have to be endured Firstly, I need a way to store fields and methods, I created a class by the inventive name of JavaClassMethod , which, unlike the name suggests, can also store fields This class allowed you to feed things like a method/field descriptor, a name, and whether the method/field is static or not, pretty basic right? In a even more basic way, I created a class called JavaClassLayout (an even more inventive name!), which stored the fields and methods a class contains, oh, and the class name Lastly, I created the class, JavaClass (my most inventive name by far), this is a class, which allows you to call functions in the class, and get results from them. JavaClass also stores a layout of the class, so you can actually find the method to call from the class structure, additionally you can extend from JavaClass to make nice mappings, like so Turns out companies don't want you to get your grubby little hands on the recipe to their coffee Minecraft is obfuscated, this means that you aren't given method names or variable names and such, rather a mangled version of the original source code. But, luckily for us, Mojang does have official mappings out in the open, as well as multiple community projects to provide custom mappings. So, I used MCP mapping viewer which allow you easily view mappings. So in credence of this knowledge, I created a JavaClassStructure class, which contains all the classes layouts, in terms of fields and methods. Note I used a nifty little pattern called MethodChaining to chain the class addition together 1 2 3 classes . addClass ( \"Minecraft\" , \"ave\" ) -> getClassAsContext ( \"Minecraft\" ) -> addMethod ( \"getMinecraft\" , \"A\" , \"()Lnet/minecraft/client/Minecraft;\" , true ); Then I built a Mapper class, which trivially stores the class structure and allows you to get different classes and such Reproducing the coffee For the last steps I just needed to test it, I did this by extending JavaClass 1 class Minecraft : public JavaClass Then using two simple methods to: Get the method getMinecraft Call the method getMinecraft This was unexpectedly trivial 1 2 3 4 5 6 7 8 9 Minecraft :: Minecraft ( MasochistClient * client ) : JavaClass :: JavaClass ( client , \"Minecraft\" ) { this -> methodGetMinecraft = getMethod ( \"getMinecraft\" ); } jobject Minecraft :: getMinecraft () { return getObject ( this -> methodGetMinecraft ); } Aftermath After an exhorbant amount of debugging, it finally worked :) Plans Some future ideas: Autogenerated mappings with a script Cross versional support Refactor to make more like a library ...","title":"Minecraft and C++"},{"location":"articles/minecraft_and_cpp/#minecraft-and-c","text":"","title":"Minecraft and C++"},{"location":"articles/minecraft_and_cpp/#foreword","text":"Interfacing with Minecraft in C++ is a relatively unexplored topic, only really explored by the likes of cheat clients, so I spent a small bit of time implementing a (small) program to interface with Minecraft, the results can be seen here I also built a small program to allow people to 'skid' from and make their own implementations pertaining to Minecraft and C++","title":"Foreword"},{"location":"articles/minecraft_and_cpp/#attack-vector","text":"So, first I had to choose the way I want to interface with Minecraft, I'm sure there are many other methods, but I decided to settle with DLL injection DLL injection would allow me to read and write to the memory of the process (Minecraft)","title":"Attack vector"},{"location":"articles/minecraft_and_cpp/#making-fire-with-my-bare-hands","text":"So I had to make the program actually compile to a DLL, this is simply done with the singular cmake line: 1 add_library ( ${ PROJECT_NAME } SHARED ${ SRC } ) Then I had to create the entry point for the program, which also can simply be done with the special entry point DllMain Note This checks if the reason for usage is to attach an executable, and if so, starts a new thread with the purpose of setting everything up and ectera 1 2 3 4 5 6 7 8 9 BOOL APIENTRY DllMain ( HINSTANCE hinstDLL , DWORD fdwReason , LPVOID lpvReserved ) { if ( fdwReason == DLL_PROCESS_ATTACH ) { CreateThread ( nullptr , 0 , ( LPTHREAD_START_ROUTINE ) injectDLL , nullptr , 0 , nullptr ); } return TRUE ; }","title":"Making fire with my bare hands"},{"location":"articles/minecraft_and_cpp/#injecting-the-poison-in-the-coffee","text":"I needed a tool with the purpose of injecting DLL's into programs. So, I had a look through the internet, and found Process Hacker , this is a pretty nifty program, that allows you to view many different things like what programs are eating away at a file you want to delete, and, as a nice bonus, it also sets of the least Windows Defender flags","title":"Injecting the poison in the coffee"},{"location":"articles/minecraft_and_cpp/#interfacing-with-coffee","text":"To actually interface with Java, I had to use a library by the name of JNI So, now with JNI in my toolkit, I need to do the following steps to mess around with Minecraft: Get the created Java virtual machines, and feed the first result into a jvm variable Get the runtime environment, this would allow me to mess with Minecraft by calling functions and such Lastly, attach the current thread to the java virtual machine That was straight forward enough to be sprawled out on a grand total of 17 lines! You may see how I did it in more depth here","title":"Interfacing with coffee"},{"location":"articles/minecraft_and_cpp/#coffee-does-not-bond-well-with-incremented-letters","text":"So, it's pretty obvious that Java isn't C++, in the slightest, which means, the pain of mapping Java to a slightly less high level language will have to be endured Firstly, I need a way to store fields and methods, I created a class by the inventive name of JavaClassMethod , which, unlike the name suggests, can also store fields This class allowed you to feed things like a method/field descriptor, a name, and whether the method/field is static or not, pretty basic right? In a even more basic way, I created a class called JavaClassLayout (an even more inventive name!), which stored the fields and methods a class contains, oh, and the class name Lastly, I created the class, JavaClass (my most inventive name by far), this is a class, which allows you to call functions in the class, and get results from them. JavaClass also stores a layout of the class, so you can actually find the method to call from the class structure, additionally you can extend from JavaClass to make nice mappings, like so","title":"Coffee does not bond well with incremented letters"},{"location":"articles/minecraft_and_cpp/#turns-out-companies-dont-want-you-to-get-your-grubby-little-hands-on-the-recipe-to-their-coffee","text":"Minecraft is obfuscated, this means that you aren't given method names or variable names and such, rather a mangled version of the original source code. But, luckily for us, Mojang does have official mappings out in the open, as well as multiple community projects to provide custom mappings. So, I used MCP mapping viewer which allow you easily view mappings. So in credence of this knowledge, I created a JavaClassStructure class, which contains all the classes layouts, in terms of fields and methods. Note I used a nifty little pattern called MethodChaining to chain the class addition together 1 2 3 classes . addClass ( \"Minecraft\" , \"ave\" ) -> getClassAsContext ( \"Minecraft\" ) -> addMethod ( \"getMinecraft\" , \"A\" , \"()Lnet/minecraft/client/Minecraft;\" , true ); Then I built a Mapper class, which trivially stores the class structure and allows you to get different classes and such","title":"Turns out companies don't want you to get your grubby little hands on the recipe to their coffee"},{"location":"articles/minecraft_and_cpp/#reproducing-the-coffee","text":"For the last steps I just needed to test it, I did this by extending JavaClass 1 class Minecraft : public JavaClass Then using two simple methods to: Get the method getMinecraft Call the method getMinecraft This was unexpectedly trivial 1 2 3 4 5 6 7 8 9 Minecraft :: Minecraft ( MasochistClient * client ) : JavaClass :: JavaClass ( client , \"Minecraft\" ) { this -> methodGetMinecraft = getMethod ( \"getMinecraft\" ); } jobject Minecraft :: getMinecraft () { return getObject ( this -> methodGetMinecraft ); }","title":"Reproducing the coffee"},{"location":"articles/minecraft_and_cpp/#aftermath","text":"After an exhorbant amount of debugging, it finally worked :)","title":"Aftermath"},{"location":"articles/minecraft_and_cpp/#plans","text":"Some future ideas: Autogenerated mappings with a script Cross versional support Refactor to make more like a library ...","title":"Plans"}]}